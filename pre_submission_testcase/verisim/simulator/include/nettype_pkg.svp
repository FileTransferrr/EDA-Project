
package wreal_nettype_pkg;

`define TYPE_IS_REAL_X(v) ((v) ===`wrealXState)
`define TYPE_IS_REAL_Z(v) ((v) ===`wrealZState)

`ifdef WREAL_DEBUG 
`define DIAG_RES_FUNC_NAME(name,num_driver) \
  if(debug_print) begin \
    $display("%0t: calling name (#drivers=%0d)", $time, num_driver); \
  end else begin end 

`define DIAG_DRIVER_1(index, val1) \
  if(debug_print) begin \
    $display("\tDriver[%0d]: (", index, val1, ")"); \
  end else begin end 

`define DIAG_DRIVER_2(index, val1, val2) \
  if(debug_print) begin \
    $display("\tDriver[%0d]: (", index, val1, ", ", val2, ")"); \
  end else begin end 

`define DIAG_DRIVER_3(index, val1, val2, val3) \
  if(debug_print) begin \
    $display("\tDriver[%0d]: (", index, val1, ", ", val2, ", ", val3, ")"); \
  end else begin end 

`define DIAG_RESOLVED_1(val) \
  if(debug_print) begin \
    $display("\tResolved Valule: (", val, ")"); \
  end else begin end 

`define DIAG_RESOLVED_2(val1, val2) \
  if(debug_print) begin \
    $display("\tResolved Valule: (", val1, ", ", val2, ")"); \
  end else begin end 

`define DIAG_RESOLVED_3(val1, val2, val3) \
  if(debug_print) begin \
    $display("\tResolved Valule: (", val1, ", ", val2, ", ", val3, ")"); \
  end else begin end 

`define DIAG_DEFAULT_VALUE_1(val) \
  if(debug_print) begin \
    $display("\tDefault Nettype Valule: ", val); \
  end else begin end 

`define DIAG_DEFAULT_VALUE_2(val1, val2) \
  if(debug_print) begin \
    $display("\tDefault Nettype Valule: (", val1, ", ", val2, ")"); \
  end else begin end 

`define DIAG_DEFAULT_VALUE_3(val1, val2, val3) \
  if(debug_print) begin \
    $display("\tDefault Nettype Valule: (", val1, ", ", val2, ", ", val3, ")");\
  end else begin end 
`else


`define DIAG_RES_FUNC_NAME(name,num_driver)
`define DIAG_DRIVER_1(index, val1) 
`define DIAG_DRIVER_2(index, val1, val2) 
`define DIAG_DRIVER_3(index, val1, val2, val3) 
`define DIAG_RESOLVED_1(val) 
`define DIAG_RESOLVED_2(val1, val2) 
`define DIAG_RESOLVED_3(val1, val2, val3) 
`define DIAG_DEFAULT_VALUE_1(val) 
`define DIAG_DEFAULT_VALUE_2(val1, val2) 
`define DIAG_DEFAULT_VALUE_3(val1, val2, val3) 

`endif


`ifdef WREAL_DEBUG
  bit debug_print; 
`endif

  function automatic real wreal_rf_def(input real driver[]);
    bit  has_drv=1'b0;

    `DIAG_RES_FUNC_NAME(wreal_rf_def, driver.size);

    if (driver.size == 1) begin
      `DIAG_DRIVER_1 (0, driver[0]);
      `DIAG_RESOLVED_1 (driver[0]);
      return driver[0]; 
    end

    if (driver.size == 0) begin
      `DIAG_DEFAULT_VALUE_1(0.0);
      return 0.0;  
    end

    wreal_rf_def = `wrealZState;
    foreach (driver[i])  begin
      `DIAG_DRIVER_1(i, driver[i]);

      if (`TYPE_IS_REAL_X(driver[i])) begin
        wreal_rf_def=`wrealXState;
        break;
      end

      if (!`TYPE_IS_REAL_Z(driver[i])) begin
        if (has_drv==1'b0) begin
          wreal_rf_def=driver[i];
          has_drv=1'b1;
        end else begin
          wreal_rf_def=`wrealXState;
          break;
        end
      end
    end

    `DIAG_RESOLVED_1(wreal_rf_def);
  endfunction

  real wreal4state_tol = 0.02;       

  function automatic bit equal_within_tol(real x, real y, real tol) ;
    real absx = (x>=0)?x:-x;
    real absy = (y>=0)?y:-y;
    real d = (absx>absy)?absx:absy;  
    real absx_minus_y = x-y; 
    if (d == 0.0) return 1'b1;
    if (absx_minus_y<0)  absx_minus_y = - absx_minus_y;
    if (absx_minus_y < tol*d)  //default tolerance of 2% allowed
      return 1'b1;
    else
      return 1'b0;
  endfunction

  function automatic real wreal_rf_4state(input real driver[]);
    bit  has_drv=1'b0;

    `DIAG_RES_FUNC_NAME(wreal_rf_4state, driver.size);

    if (driver.size == 1) begin
      `DIAG_DRIVER_1 (0, driver[0]);
      `DIAG_RESOLVED_1 (driver[0]);
      return driver[0]; 
    end

    if (driver.size == 0) begin
      `DIAG_DEFAULT_VALUE_1(0.0);
      return 0.0;  
    end

    wreal_rf_4state = `wrealZState;
    foreach (driver[i])  begin
      `DIAG_DRIVER_1(i, driver[i]);

      if (`TYPE_IS_REAL_X(driver[i])) begin
        wreal_rf_4state=`wrealXState;
        break;
      end

      if (!`TYPE_IS_REAL_Z(driver[i])) begin
        if (has_drv==1'b0) begin
          wreal_rf_4state=driver[i];
          has_drv=1'b1;
        end if (equal_within_tol(wreal_rf_4state,driver[i],wreal4state_tol)==1'b0) begin
          wreal_rf_4state=`wrealXState;
          break;
        end
      end
    end

    `DIAG_RESOLVED_1(wreal_rf_4state);
  endfunction

  function automatic real wreal_rf_sum(input real driver[]);
    bit  has_drv=1'b0;

    `DIAG_RES_FUNC_NAME(wreal_rf_sum, driver.size);

    if (driver.size == 1) begin
      `DIAG_DRIVER_1(0, driver[0]);
      `DIAG_RESOLVED_1(driver[0]);
      return driver[0]; 
    end

    if (driver.size == 0) begin
      `DIAG_DEFAULT_VALUE_1 (0.0);
      return 0.0;  
    end

    // General case: scan each driver in the loop
    wreal_rf_sum = `wrealZState;
    foreach (driver[i])  begin
      `DIAG_DRIVER_1(i, driver[i]);

      if (`TYPE_IS_REAL_X(driver[i])) begin
        wreal_rf_sum=`wrealXState;
        break;
      end
      if (!`TYPE_IS_REAL_Z(driver[i])) begin
        if (has_drv == 1'b0) begin
          has_drv = 1'b1;
          wreal_rf_sum = driver[i];
        end 
        else begin
          wreal_rf_sum += driver[i];
        end
      end
    end

    `DIAG_RESOLVED_1(wreal_rf_sum);
  endfunction

  function automatic real wreal_rf_avg(input real driver[]);
    real drvrs;

    `DIAG_RES_FUNC_NAME(wreal_rf_avg, driver.size);

    if (driver.size == 1) begin
      `DIAG_DRIVER_1 (0, driver[0]);
      `DIAG_RESOLVED_1 (driver[0]);
      return driver[0];
    end

    if (driver.size == 0) begin
      `DIAG_DEFAULT_VALUE_1 (0.0);
      return 0.0;  
    end
    
    drvrs = 0.0;
    wreal_rf_avg = 0.0;
    foreach (driver[i])  begin
      `DIAG_DRIVER_1 (i, driver[i]);

      if (`TYPE_IS_REAL_X(driver[i])) begin
        wreal_rf_avg=`wrealXState;
        `DIAG_RESOLVED_1 (wreal_rf_avg);
        return wreal_rf_avg;
      end
      if (!`TYPE_IS_REAL_Z(driver[i])) begin
        wreal_rf_avg+=driver[i];
        drvrs += 1.0;
      end
    end

    if (drvrs == 0.0) begin
      wreal_rf_avg = `wrealZState;
    end
    else begin
      wreal_rf_avg = wreal_rf_avg/drvrs;
    end

    `DIAG_RESOLVED_1 (wreal_rf_avg);
  endfunction

  function automatic real wreal_rf_min(input real driver[]);
    bit first_driver=1'b1;

    `DIAG_RES_FUNC_NAME(wreal_rf_min, driver.size);

    if (driver.size == 1) begin
      `DIAG_DRIVER_1 (0, driver[0]);
      `DIAG_RESOLVED_1 (driver[0]);
      return driver[0]; 
    end

    if (driver.size == 0) begin
      `DIAG_DEFAULT_VALUE_1 (0.0);
      return 0.0;  
    end

    wreal_rf_min = `wrealZState;
    foreach (driver[i])  begin
      `DIAG_DRIVER_1 (i, driver[i]);

      if (`TYPE_IS_REAL_X(driver[i])) begin
        wreal_rf_min=`wrealXState;
        break;
      end
      if (!`TYPE_IS_REAL_Z(driver[i])) begin
        if (first_driver) begin
          wreal_rf_min=driver[i];
          first_driver=1'b0;
        end else if (wreal_rf_min>driver[i]) begin
          wreal_rf_min=driver[i];
        end
      end
    end

    `DIAG_RESOLVED_1 (wreal_rf_min);
  endfunction

  function automatic real wreal_rf_max(input real driver[]);
    bit first_driver=1'b1;

    `DIAG_RES_FUNC_NAME(wreal_rf_max, driver.size);

    if (driver.size == 1) begin
      `DIAG_DRIVER_1 (0, driver[0]);
      `DIAG_RESOLVED_1 (driver[0]);
      return driver[0]; 
    end

    if (driver.size == 0) begin
      `DIAG_DEFAULT_VALUE_1 (0.0);
      return 0.0;  
    end

    wreal_rf_max = `wrealZState; 
    foreach (driver[i])  begin
      `DIAG_DRIVER_1 (i, driver[i]);

      if (`TYPE_IS_REAL_X(driver[i])) begin
        wreal_rf_max=`wrealXState;
        break;
      end
      if (!`TYPE_IS_REAL_Z(driver[i])) begin
        if (first_driver) begin
          wreal_rf_max=driver[i];
          first_driver=1'b0;
        end else if (wreal_rf_max<driver[i]) begin
          wreal_rf_max=driver[i];
        end
      end
    end

    `DIAG_RESOLVED_1 (wreal_rf_max);
  endfunction



  const real realX = `wrealXState;
  const real realZ = `wrealZState;

  nettype real wreal1driver with wreal_rf_def;
  nettype real wreal4state  with wreal_rf_4state;
  nettype real wrealsum     with wreal_rf_sum;

  nettype real wrealavg     with wreal_rf_avg;
  nettype real wrealmin     with wreal_rf_min;
  nettype real wrealmax     with wreal_rf_max;

  function automatic real rf_1_driver(input real driver[]);
    bit  has_drv=1'b0;

    `DIAG_RES_FUNC_NAME(rf_1_driver, driver.size);

    if (driver.size == 1) begin
      `DIAG_DRIVER_1 (0, driver[0]);
      `DIAG_RESOLVED_1 (driver[0]);
      return driver[0]; 
    end

    if (driver.size == 0) begin
      `DIAG_DEFAULT_VALUE_1(0.0);
      return 0.0;  
    end

    rf_1_driver = realZ;
    foreach (driver[i])  begin
      `DIAG_DRIVER_1(i, driver[i]);

      if (`TYPE_IS_REAL_X(driver[i])) begin
        rf_1_driver=realX;
        break;
      end

      if (!`TYPE_IS_REAL_Z(driver[i])) begin
        if (has_drv==1'b0) begin
          rf_1_driver=driver[i];
          has_drv=1'b1;
        end else begin
          rf_1_driver=realX;
          break;
        end
      end
    end

    `DIAG_RESOLVED_1(rf_1_driver);
  endfunction

  function automatic real rf_sum_of_drivers(input real driver[]);
    bit  has_drv=1'b0;

    `DIAG_RES_FUNC_NAME(rf_sum_of_drivers, driver.size);

    if (driver.size == 1) begin
      `DIAG_DRIVER_1(0, driver[0]);
      `DIAG_RESOLVED_1(driver[0]);
      return driver[0]; 
    end

    if (driver.size == 0) begin
      `DIAG_DEFAULT_VALUE_1 (0.0);
      return 0.0;  
    end

    rf_sum_of_drivers = realZ;
    foreach (driver[i])  begin
      `DIAG_DRIVER_1(i, driver[i]);

      if (`TYPE_IS_REAL_X(driver[i])) begin
        rf_sum_of_drivers=realX;
        break;
      end
      if (!`TYPE_IS_REAL_Z(driver[i])) begin
        if (has_drv == 1'b0) begin
          has_drv = 1'b1;
          rf_sum_of_drivers = driver[i];
        end 
        else begin
          rf_sum_of_drivers += driver[i];
        end
      end
    end

    `DIAG_RESOLVED_1(rf_sum_of_drivers);
  endfunction

  nettype real voltage_r with rf_1_driver;
  nettype real current_r with rf_sum_of_drivers;

  typedef struct {
    real v;
    logic active;
  } v_wiret;

  function automatic v_wiret v_wire_rf_avg(input v_wiret driver[]); 
    int count = 0;

    `DIAG_RES_FUNC_NAME(v_wire_rf_avg, driver.size);

    if (driver.size == 1) begin
      if (driver[0].active===1'b1) begin
        v_wire_rf_avg = driver[0];
      end
      else begin
        v_wire_rf_avg.v = 0.0;
        v_wire_rf_avg.active = driver[0].active;
      end

      `DIAG_DRIVER_2 (0, driver[0].v, driver[0].active);
      `DIAG_RESOLVED_2 (v_wire_rf_avg.v ,v_wire_rf_avg.active);
      return v_wire_rf_avg; 
    end

    v_wire_rf_avg = '{0.0,1'bz}; 

    if (driver.size == 0) begin
      `DIAG_DEFAULT_VALUE_2(v_wire_rf_avg.v ,v_wire_rf_avg.active);
      return v_wire_rf_avg;  
    end

    foreach (driver[i]) begin
     `DIAG_DRIVER_2 (i, driver[i].v, driver[i].active);

     if (driver[i].active===1'bx) begin
        v_wire_rf_avg.v=0.0;
        v_wire_rf_avg.active=1'bx;
        count=0;
        break;
      end
      if (driver[i].active==1'b1) begin //drives when active=1
        v_wire_rf_avg.v += driver[i].v;
        count++; 
      end
    end

    if (count > 0) begin
      v_wire_rf_avg = '{(v_wire_rf_avg.v / count), 1'b1}; 
    end
      
    `DIAG_RESOLVED_2 (v_wire_rf_avg.v, v_wire_rf_avg.active);

    return v_wire_rf_avg;
  endfunction   

  function automatic v_wiret v_wire_rf_sum(input v_wiret driver[]); 
    `DIAG_RES_FUNC_NAME(v_wire_rf_sum, driver.size);

    if (driver.size == 1) begin
      if (driver[0].active===1'b1) begin
        v_wire_rf_sum = driver[0];
      end
      else begin
        v_wire_rf_sum.v = 0.0;
        v_wire_rf_sum.active = driver[0].active;
      end

      `DIAG_DRIVER_2 (0, driver[0].v, driver[0].active);
      `DIAG_RESOLVED_2 (v_wire_rf_sum.v ,v_wire_rf_sum.active);

      return v_wire_rf_sum;
    end

    v_wire_rf_sum = '{0.0,1'bz};

    if (driver.size == 0) begin
      `DIAG_DEFAULT_VALUE_2(v_wire_rf_sum.v, v_wire_rf_sum.active);
      return v_wire_rf_sum;  
    end

    foreach (driver[i]) begin
     `DIAG_DRIVER_2 (i, driver[i].v, driver[i].active);

     if (driver[i].active===1'bx) begin
        v_wire_rf_sum.v=0.0;
        v_wire_rf_sum.active=1'bx;
        break;
      end
      if (driver[i].active==1'b1) begin //drives when active=1
        v_wire_rf_sum.active = 1'b1;
        v_wire_rf_sum.v += driver[i].v;
      end
    end

    `DIAG_RESOLVED_2 (v_wire_rf_sum.v ,v_wire_rf_sum.active);
  endfunction   
 
  function automatic v_wiret v_wire_rf_one(input v_wiret driver[]); 
    int count = 0;

    `DIAG_RES_FUNC_NAME(v_wire_rf_one, driver.size);

    if (driver.size == 1) begin
      if (driver[0].active === 1'b1) begin
        v_wire_rf_one = driver[0];
      end
      else begin
        v_wire_rf_one.v = 0.0;
        v_wire_rf_one.active  = driver[0].active;
      end

      `DIAG_DRIVER_2 (0, driver[0].v, driver[0].active);
      `DIAG_RESOLVED_2 (v_wire_rf_one.v ,v_wire_rf_one.active);

      return v_wire_rf_one;
    end

    v_wire_rf_one = '{0.0,1'bz};

    if (driver.size == 0) begin
      `DIAG_DEFAULT_VALUE_2(v_wire_rf_one.v ,v_wire_rf_one.active);
      return v_wire_rf_one;  
    end

    foreach (driver[i]) begin
      `DIAG_DRIVER_2 (i, driver[i].v, driver[i].active);

      if (driver[i].active===1'bx) begin
        v_wire_rf_one.v=0.0;
        v_wire_rf_one.active=1'bx;
        break;
      end

      if (driver[i].active===1'b1) begin //drives when active=1
        count++;
        if (count > 1)  begin // too many drivers, set v=0.0
          v_wire_rf_one.active = 1'bx;
          v_wire_rf_one.v = 0.0;
          break;
        end 

        v_wire_rf_one.active = 1'b1;
        v_wire_rf_one.v = driver[i].v;
      end
    end
    
    `DIAG_RESOLVED_2 (v_wire_rf_one.v ,v_wire_rf_one.active);
  endfunction

  function automatic v_wiret v_wire_rf_4state(input v_wiret driver[]); 
    int count = 0;

    `DIAG_RES_FUNC_NAME(v_wire_rf_4state, driver.size);

    if (driver.size == 1) begin
      if (driver[0].active===1'b1) begin
        v_wire_rf_4state = driver[0];
      end
      else begin
        v_wire_rf_4state.v = 0.0;
        v_wire_rf_4state.active = driver[0].active;
      end

      `DIAG_DRIVER_2 (0, driver[0].v, driver[0].active);
      `DIAG_RESOLVED_2 (v_wire_rf_4state.v, v_wire_rf_4state.active);

      return v_wire_rf_4state;
    end

    v_wire_rf_4state = '{0.0,1'bz};

    if (driver.size == 0) begin
      `DIAG_DEFAULT_VALUE_2 (v_wire_rf_4state.v ,v_wire_rf_4state.active);
      return v_wire_rf_4state;  
    end

    foreach (driver[i]) begin
     `DIAG_DRIVER_2 (i, driver[i].v, driver[i].active);

     if (driver[i].active===1'bx) begin
        v_wire_rf_4state.v=0.0;
        v_wire_rf_4state.active=1'bx;
        break;
      end
      if (driver[i].active==1'b1) begin //drives when active=1
        count++;
        if (count > 1)  begin // too many drivers, set v=0.0
          if (driver[i].v != v_wire_rf_4state.v ) begin
            v_wire_rf_4state.active = 1'bx;
            v_wire_rf_4state.v = 0.0;
            break;
          end 
        end
        else begin
          v_wire_rf_4state.active = 1'b1;
          v_wire_rf_4state.v = driver[i].v;
        end
      end
    end

    `DIAG_RESOLVED_2 (v_wire_rf_4state.v ,v_wire_rf_4state.active);
  endfunction

  function automatic v_wiret v_wire_rf_min(input v_wiret driver[]); 
    int count = 0;

    `DIAG_RES_FUNC_NAME(v_wire_rf_min, driver.size);

    if (driver.size == 1) begin
      if (driver[0].active === 1'b1) begin
        v_wire_rf_min = driver[0];
      end
      else begin
        v_wire_rf_min.v = 0.0;
        v_wire_rf_min.active = driver[0].active;
      end

      `DIAG_DRIVER_2 (0, driver[0].v, driver[0].active);
      `DIAG_RESOLVED_2 (v_wire_rf_min.v ,v_wire_rf_min.active);

      return v_wire_rf_min;
    end

    v_wire_rf_min = '{0.0,1'bz};

    if (driver.size == 0) begin
      `DIAG_DEFAULT_VALUE_2 ( v_wire_rf_min.v ,v_wire_rf_min.active);
      return v_wire_rf_min;  
    end

    foreach (driver[i]) begin
      `DIAG_DRIVER_2 (i, driver[i].v, driver[i].active);

      if (driver[i].active===1'bx) begin
        v_wire_rf_min.v=0.0;
        v_wire_rf_min.active=1'bx;
        break;
      end

      if (driver[i].active===1'b1) begin //drives when active=1
        count++;
        if (count > 1)  begin //result already initialized
          if (driver[i].v < v_wire_rf_min.v ) begin
            v_wire_rf_min.v = driver[i].v;
          end
        end else begin //first driver
          v_wire_rf_min.v = driver[i].v;
          v_wire_rf_min.active = 1'b1;
        end
      end
    end

    `DIAG_RESOLVED_2 (v_wire_rf_min.v ,v_wire_rf_min.active);
  endfunction

  function automatic v_wiret v_wire_rf_max(input v_wiret driver[]); 
    int count = 0;

    `DIAG_RES_FUNC_NAME(v_wire_rf_max, driver.size);

    if (driver.size == 1) begin
      if (driver[0].active===1'b1) begin
        v_wire_rf_max = driver[0];
      end
      else begin
        v_wire_rf_max.v = 0.0;
        v_wire_rf_max.active = driver[0].active;
      end

      `DIAG_DRIVER_2 (0, driver[0].v, driver[0].active);
      `DIAG_RESOLVED_2 (v_wire_rf_max.v ,v_wire_rf_max.active);

      return v_wire_rf_max;
    end

    v_wire_rf_max = '{0.0,1'bz};

    if (driver.size == 0) begin
      `DIAG_DEFAULT_VALUE_2 (v_wire_rf_max.v ,v_wire_rf_max.active);
      return v_wire_rf_max;  
    end

    foreach (driver[i]) begin
     `DIAG_DRIVER_2 (i, driver[i].v, driver[i].active);

     if (driver[i].active===1'bx) begin
        v_wire_rf_max.v=0.0;
        v_wire_rf_max.active=1'bx;
        break;
      end
      if (driver[i].active===1'b1) begin //drives when active=1
        count++;
        if (count > 1)  begin //result already initialized
          if (driver[i].v > v_wire_rf_max.v ) begin
            v_wire_rf_max.v = driver[i].v;
          end
        end else begin //first driver
          v_wire_rf_max.v = driver[i].v;
          v_wire_rf_max.active = 1'b1;
        end
      end
    end

    `DIAG_RESOLVED_2 (v_wire_rf_max.v ,v_wire_rf_max.active);
  endfunction

  nettype v_wiret  v_wire_one  with v_wire_rf_one;
  nettype v_wiret  v_wire_4state  with v_wire_rf_4state;
  nettype v_wiret  v_wire_sum  with v_wire_rf_sum;

  nettype v_wiret  v_wire_avg  with v_wire_rf_avg;
  nettype v_wiret  v_wire_min  with v_wire_rf_min;
  nettype v_wiret  v_wire_max  with v_wire_rf_max;

  typedef struct {
    real i;
    logic active;
  } i_wiret;

  function automatic i_wiret i_wire_rf(input i_wiret driver[]); 

    `DIAG_RES_FUNC_NAME(i_wire_rf, driver.size);

    if (driver.size == 1) begin
      if (driver[0].active === 1'b1) begin
          i_wire_rf = driver[0];
      end
      else begin
          i_wire_rf.i = 0.0;
          i_wire_rf.active = driver[0].active;
      end

      `DIAG_DRIVER_2 (0, driver[0].i, driver[0].active);
      `DIAG_RESOLVED_2 (i_wire_rf.i ,i_wire_rf.active);

      return i_wire_rf; 
    end

    i_wire_rf = '{0.0,1'bz}; // resolved value when there's no active driver

    if (driver.size == 0) begin
      `DIAG_DEFAULT_VALUE_2 (i_wire_rf.i ,i_wire_rf.active);
      return i_wire_rf;  
    end

    foreach (driver[i]) begin
      `DIAG_DRIVER_2 (i, driver[i].i, driver[i].active);

      if (driver[i].active===1'bx) begin
        i_wire_rf.i=0.0;
        i_wire_rf.active=1'bx;
        break;
      end
      if (driver[i].active===1'b1) begin
        i_wire_rf.active = 1'b1;
        i_wire_rf.i += driver[i].i; 
      end
    end

    `DIAG_RESOLVED_2 (i_wire_rf.i ,i_wire_rf.active);
  endfunction

  nettype i_wiret  i_wire      with i_wire_rf;

  typedef struct {
    real vth;
    real rth;
    logic active;
  } th_wiret;

function automatic th_wiret th_wire_rf(input th_wiret driver[]);
    int count = 0;
    real geq = 0.0;
    real ieq =0.0;
    int count_zero_rth = 0; // number of drivers with rth=0

    `DIAG_RES_FUNC_NAME(th_wire_rf, driver.size);

    if (driver.size == 1) begin
      if (driver[0].active === 1'b1) begin
        th_wire_rf = driver[0];
      end
      else begin
        th_wire_rf.vth = 0.0;
        th_wire_rf.rth = 0.0;
        th_wire_rf.active = driver[0].active;
      end

      `DIAG_DRIVER_3 (0, driver[0].vth,  driver[0].rth, driver[0].active);
      `DIAG_RESOLVED_3 (driver[0].vth,  driver[0].rth, driver[0].active);
      return th_wire_rf; 
    end

    th_wire_rf = '{0.0, 0.0, 1'bz}; 

    if (driver.size == 0) begin
      `DIAG_DEFAULT_VALUE_3(th_wire_rf.vth, th_wire_rf.rth, th_wire_rf.active);
      return th_wire_rf;  
    end

    foreach (driver[i]) begin
      `DIAG_DRIVER_3 (i, driver[i].vth,  driver[i].rth, driver[i].active);

      if (driver[i].active === 1'bx) begin
        th_wire_rf = '{0.0, 0.0, 1'bx}; 
        `DIAG_RESOLVED_3 (th_wire_rf.vth, th_wire_rf.rth, th_wire_rf.active);
        return th_wire_rf;
      end

      if (driver[i].active === 1'b1) begin
        if (driver[i].rth == 0.0) begin
          count_zero_rth++;
          if (count_zero_rth > 1) begin
            th_wire_rf.vth=0.0;  
            th_wire_rf.rth=-1.0;     // set a marker for undefined value
            th_wire_rf.active = 1'bx;

            `DIAG_RESOLVED_3(th_wire_rf.vth,th_wire_rf.rth,th_wire_rf.active);
            return th_wire_rf;
          end

          th_wire_rf.vth = driver[i].vth;
          th_wire_rf.rth = 0.0;
          th_wire_rf.active = 1'b1;
        end
        else if (count_zero_rth == 0)
        begin
          geq += 1/driver[i].rth;
          ieq += driver[i].vth/driver[i].rth;
        end
        count++;
      end
    end
    if (count == 0) begin //no active drivers
      th_wire_rf.vth = 0.0;
      th_wire_rf.rth = 0.0;
      th_wire_rf.active = 1'bz;
    end
    else if (count_zero_rth == 0) begin
      th_wire_rf.rth=1.0/geq;
      th_wire_rf.vth=ieq/geq;
      th_wire_rf.active = 1'b1;
    end

    `DIAG_RESOLVED_3 (th_wire_rf.vth, th_wire_rf.rth, th_wire_rf.active);
  endfunction

  nettype th_wiret th_wire     with th_wire_rf;

  typedef struct {
    real r;
  } r_wiret;

  nettype r_wiret  r_wire;




endpackage : wreal_nettype_pkg
